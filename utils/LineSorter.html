<!DOCTYPE html><html lang="en"><head><title>utils/LineSorter</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="utils/LineSorter"><meta name="groc-project-path" content="src/main/scala/net/pierreandrews/utils/LineSorter.scala"><meta name="groc-github-url" content="https://github.com/Mortimerp9/LogSplit"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Mortimerp9/LogSplit/blob/master/src/main/scala/net/pierreandrews/utils/LineSorter.scala">src/main/scala/net/pierreandrews/utils/LineSorter.scala</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="k">package</span> <span class="nn">net.pierreandrews.utils</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>An Iterator that takes in a set of partially sorted inputs and merges them in a sorted manned, in descending order.</p>
<p>If the inputs are not partially sorted, than the output will not be sorted properly. This sorter more or less
only needs inputs.size*size(I) memory as it lazily loads each line from the inputs.</p>
<p>The second parameter is a function that extracts the field to be sorted on. It extracts it in an Option as the extraction
might fail (i.e. we can&#39;t parse the date out of the logline)</p>
<p>User: pierre
Date: 11/30/14</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nc">LineSorter</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">T:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Iterator</span><span class="o">[</span><span class="kt">I</span><span class="o">]],</span> <span class="n">extractOrderField</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span> <span class="o">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>filter out the log lines to only keep the ones
which are parseable.
This flatMap is done on an iterator, so it&#39;s executed lazily only when the line is pulled.</p></div></div><div class="code"><div class="wrapper">  <span class="k">private</span> <span class="k">val</span> <span class="n">bufferedInputs</span> <span class="k">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">l</span><span class="k">=&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get rid of the lines we can&#39;t parse</p></div></div><div class="code"><div class="wrapper">    <span class="n">extractOrderField</span><span class="o">(</span><span class="n">l</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}.</span><span class="n">buffered</span><span class="o">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we buffer the iterator so that we can peak at the top of the iterator without moving it forward.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> there are more lines in this iterator if at least one of the underlying iterators has more lines</p></div></div><div class="code"><div class="wrapper">  <span class="k">override</span> <span class="k">def</span> <span class="n">hasNext</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">bufferedInputs</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
  <span class="o">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>extract the next line, choosing the one with the maximum sorting field from all the available iterators
returns the maximum next line</p></div></div><div class="code"><div class="wrapper">  <span class="k">override</span> <span class="k">def</span> <span class="n">next</span><span class="o">()</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=</span> <span class="o">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>only get the possible next line from the iterators that still have content available
we will then figure out which one to return</p></div></div><div class="code"><div class="wrapper">    <span class="k">val</span> <span class="n">possibleNext</span> <span class="k">=</span> <span class="n">bufferedInputs</span><span class="o">.</span><span class="n">collect</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">it</span> <span class="k">if</span> <span class="n">it</span><span class="o">.</span><span class="n">hasNext</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">head</span><span class="o">,</span> <span class="n">it</span><span class="o">)</span>
    <span class="o">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>find out the maximum ordering field from the possible next lines
maxBy will sort the iterator in descending order.</p></div></div><div class="code"><div class="wrapper">    <span class="k">val</span> <span class="o">((</span><span class="n">sortField</span><span class="o">,</span> <span class="n">maxNext</span><span class="o">),</span> <span class="n">itToAdvance</span><span class="o">)</span> <span class="k">=</span> <span class="n">possibleNext</span><span class="o">.</span><span class="n">maxBy</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">((</span><span class="n">headOrder</span><span class="o">,</span> <span class="k">_</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">headOrder</span>
    <span class="o">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move the chosen iterator forward</p></div></div><div class="code"><div class="wrapper">    <span class="n">itToAdvance</span><span class="o">.</span><span class="n">next</span><span class="o">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return the line from that iterator</p></div></div><div class="code"><div class="wrapper">    <span class="n">maxNext</span>
  <span class="o">}</span>
<span class="o">}</span></div></div></div></div></body></html>