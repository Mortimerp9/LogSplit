<!DOCTYPE html><html lang="en"><head><title>utils/LineSorter</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="utils/LineSorter"><meta name="groc-project-path" content="src/main/scala/net/pierreandrews/utils/LineSorter.scala"><meta name="groc-github-url" content="https://github.com/Mortimerp9/LogSplit"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Mortimerp9/LogSplit/blob/master/src/main/scala/net/pierreandrews/utils/LineSorter.scala">src/main/scala/net/pierreandrews/utils/LineSorter.scala</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> net.pierreandrews.utils</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>An Iterator that takes in a set of partially sorted inputs and merges them in a sorted manned, in descending order.</p>
<p>If the inputs are not partially sorted, than the output will not be sorted properly. This sorter more or less
only needs inputs.size*size(I) memory as it lazily loads each line from the inputs.</p>
<p>The second parameter is a function that extracts the field to be sorted on. It extracts it in an Option as the extraction
might fail (i.e. we can&#39;t parse the date out of the logline)</p>
<p>User: pierre
Date: 11/30/14</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LineSorter</span>[</span><span class="hljs-type">I</span>, <span class="hljs-type">T</span>: <span class="hljs-type">Ordering</span>](inputs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Iterator</span>[<span class="hljs-type">I</span>]], extractOrderField: <span class="hljs-type">I</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">T</span>]) <span class="hljs-keyword">extends</span> <span class="hljs-type">Iterator</span>[<span class="hljs-type">I</span>] {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>filter out the log lines to only keep the ones
which are parseable.
This flatMap is done on an iterator, so it&#39;s executed lazily only when the line is pulled.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">bufferedInputs</span> =</span> inputs.map(_.flatMap { l=&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get rid of the lines we can&#39;t parse</p></div></div><div class="code"><div class="wrapper">    extractOrderField(l).map { (_, l) }
  }.buffered)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we buffer the iterator so that we can peak at the top of the iterator without moving it forward.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> there are more lines in this iterator if at least one of the underlying iterators has more lines</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasNext</span>:</span> <span class="hljs-type">Boolean</span> = {
    bufferedInputs.exists(_.hasNext)
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>extract the next line, choosing the one with the maximum sorting field from all the available iterators
returns the maximum next line</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span>(</span>): <span class="hljs-type">I</span> = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>only get the possible next line from the iterators that still have content available
we will then figure out which one to return</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">possibleNext</span> =</span> bufferedInputs.collect {
      <span class="hljs-keyword">case</span> it <span class="hljs-keyword">if</span> it.hasNext =&gt;
        (it.head, it)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>find out the maximum ordering field from the possible next lines
maxBy will sort the iterator in descending order.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">val</span> (</span>(sortField, maxNext), itToAdvance) = possibleNext.maxBy {
      <span class="hljs-keyword">case</span> ((headOrder, _), _) =&gt;
        headOrder
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move the chosen iterator forward</p></div></div><div class="code"><div class="wrapper">    itToAdvance.next()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return the line from that iterator</p></div></div><div class="code"><div class="wrapper">    maxNext
  }
}</div></div></div></div></body></html>