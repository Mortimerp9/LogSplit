<!DOCTYPE html><html lang="en"><head><title>ReaderActor</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="ReaderActor"><meta name="groc-project-path" content="src/main/scala/net/pierreandrews/ReaderActor.scala"><meta name="groc-github-url" content="https://github.com/Mortimerp9/LogSplit"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Mortimerp9/LogSplit/blob/master/src/main/scala/net/pierreandrews/ReaderActor.scala">src/main/scala/net/pierreandrews/ReaderActor.scala</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">package</span> net.pierreandrews

<span class="hljs-keyword">import</span> java.io.{ <span class="hljs-type">File</span>, <span class="hljs-type">FilenameFilter</span> }

<span class="hljs-keyword">import</span> akka.event.<span class="hljs-type">LoggingReceive</span>
<span class="hljs-keyword">import</span> net.pierreandrews.utils.<span class="hljs-type">LogSplitUtils</span>.<span class="hljs-type">JoinIterators</span>

<span class="hljs-keyword">import</span> scala.annotation.tailrec
<span class="hljs-keyword">import</span> scala.collection.mutable
<span class="hljs-keyword">import</span> scala.collection.mutable.<span class="hljs-type">ListBuffer</span>
<span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">Source</span>

<span class="hljs-keyword">import</span> akka.actor.{ <span class="hljs-type">ActorLogging</span>, <span class="hljs-type">Actor</span>, <span class="hljs-type">ActorRef</span>, <span class="hljs-type">RootActorPath</span> }
<span class="hljs-keyword">import</span> akka.cluster.{ <span class="hljs-type">Cluster</span>, <span class="hljs-type">Member</span>, <span class="hljs-type">MemberStatus</span> }
<span class="hljs-keyword">import</span> akka.cluster.<span class="hljs-type">ClusterEvent</span>.{ <span class="hljs-type">MemberRemoved</span>, <span class="hljs-type">CurrentClusterState</span>, <span class="hljs-type">MemberUp</span> }
<span class="hljs-keyword">import</span> net.pierreandrews.<span class="hljs-type">Protocol</span>._

<span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">NonFatal</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A reader actor is responsible for reading logs from the local filesystem and distributing them to the writer nodes.</p>
<p>Each reader contacts the cluster and registers on ALL nodes. The nodes are responsible for assigning a writer to the
reader. Each reader communicates with one and only one worker on each node.</p>
<p>A reader is responsible for reading all the lines from a set of consecutive buckets, it will append inputFiles in order
and lazily read from that iterator.</p>
<p>Each reader works in parallel on a different set of local files. A reader doesn&#39;t know about other readers and works on files
that are only assigned to it, so we have no concurrency issues accessing files.</p>
<p>Because lines are in order in the local files processed by a reader, it offers them in order to the writers.</p>
<p>Not all writers might be executing at the same speed (one could be on another node that is slower, or has a slower IO), but lines
in the files are sequential an one line can only go to one worker.
If the line at the top of the file is assigned to a worker that is blocked or unreachable, the reader (and all its assigned writers) will
be blocked too.
To avoid being bound by the slowest node/IO in the cluster, each reader keeps a buffer of next lines so that it can advance in the file even
if one worker is blocked for a bit and distribute lines to other writers. If users are randomly distributed in the log files, and because we used
a balanced partitioning (see Parser.partition), then this works well. Increasing the buffer size will require more memory but will allow for
a faster processing.</p>
<p>Writers send a RequestLog message to all their readers, they will then be idle until they receive a log line or a message to ping the readers again.
It&#39;s up to the reader to send this message in a timely manner or the cluster will be blocked. We do not send log lines proactively (push) to the
writers as we do not want to overflow their message queues and memory.</p>
<p>User: pierre
Date: 11/28/14</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderActor</span>(</span>args: <span class="hljs-type">LogSplitAppArgs</span>, inputFiles: <span class="hljs-type">Seq</span>[<span class="hljs-type">File</span>], partIdx: <span class="hljs-type">Int</span>, totalReaders: <span class="hljs-type">Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-type">Actor</span> <span class="hljs-keyword">with</span> <span class="hljs-type">ActorLogging</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the akka cluster to communicate wiht</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">cluster</span> =</span> <span class="hljs-type">Cluster</span>(context.system)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we have one writer actor per node. Array is indexed by server id</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">writers</span>:</span> <span class="hljs-type">Array</span>[<span class="hljs-type">ActorRef</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(args.numServers)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>keep track of which writer asked for a logline that couldn&#39;t be delivered (because its queue was empty)
array is indexed by server id</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">blockedWriters</span>:</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Boolean</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(args.numServers)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>number of registered writers</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> registeredWriters = <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we keep a buffer of lines in advance for each server to avoid being blocked by one single slow node.
The queues are not strictly bounded but we never push more than args.maxReadBuffer lines per partition (see fillUpQueue() ).</p>
<p>The Seq is indexed per server id</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">logsToDeliver</span>:</span> <span class="hljs-type">IndexedSeq</span>[mutable.<span class="hljs-type">Queue</span>[<span class="hljs-type">IdAndLine</span>]] = <span class="hljs-keyword">for</span> {
    i &lt;- <span class="hljs-number">0</span> until args.numServers
  } <span class="hljs-keyword">yield</span> {
    mutable.<span class="hljs-type">Queue</span>[<span class="hljs-type">IdAndLine</span>]()
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>use a BufferedIterator to look at the head of the iterator
without discarding it (i.e. there is always one line in memory+the ones in the queue)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">lines</span>:</span> <span class="hljs-type">BufferedIterator</span>[<span class="hljs-type">IdAndLine</span>] = lineIterator()

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preStart</span>(</span>): <span class="hljs-type">Unit</span> = {
    log.info(<span class="hljs-string">"starting reader {}.{} on files {}"</span>, args.serverID, partIdx, inputFiles.map(_.getAbsolutePath).mkString(<span class="hljs-string">","</span>))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>subscribe to cluster changes</p></div></div><div class="code"><div class="wrapper">    cluster.subscribe(self, classOf[<span class="hljs-type">MemberUp</span>])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>fill up the queues in preparation for writers pulling work</p></div></div><div class="code"><div class="wrapper">    fillUpQueue()
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>re-subscribe when restart</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postStop</span>(</span>): <span class="hljs-type">Unit</span> = cluster.unsubscribe(self)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>start in a cluster management mode. When all nodes are setup, move to an active mode where we
can send logs to writers</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive</span>:</span> <span class="hljs-type">Receive</span> = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>/////////////// cluster management</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">case</span> state: <span class="hljs-type">CurrentClusterState</span> =&gt;
      state.members.filter(_.status == <span class="hljs-type">MemberStatus</span>.<span class="hljs-type">Up</span>) foreach register
    <span class="hljs-keyword">case</span> <span class="hljs-type">MemberUp</span>(m) =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>a new node joins, go register on it</p></div></div><div class="code"><div class="wrapper">      register(m)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>connect to writers that we are assigned to</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">case</span> <span class="hljs-type">RegisterWriter</span>(id) =&gt;
      log.info(s<span class="hljs-string">"Writer {} registering on {}.{}"</span>, id, args.serverID, partIdx)
      writers(id) = sender()
      registeredWriters += <span class="hljs-number">1</span>
      <span class="hljs-keyword">if</span> (registeredWriters &gt;= args.numServers) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>once all the writers have registered, we can start working</p></div></div><div class="code"><div class="wrapper">        log.info(<span class="hljs-string">"Reader {}.{} is becoming active"</span>, args.serverID, partIdx)
        context.become(activeReader)
        notifyWriters()
      }

    <span class="hljs-keyword">case</span> <span class="hljs-type">RequestLog</span>(requestServerId) <span class="hljs-keyword">if</span> requestServerId &lt; args.numServers =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we are not active yet, whatever writer ask for work will have to block for a bit</p></div></div><div class="code"><div class="wrapper">      blockedWriters(requestServerId) = <span class="hljs-literal">true</span>
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>active working mode, deal with log requests from writers</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activeReader</span>:</span> <span class="hljs-type">Receive</span> = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>//////////////// log distribution logic</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">case</span> <span class="hljs-type">RequestLog</span>(requestServerId) <span class="hljs-keyword">if</span> requestServerId &lt; args.numServers =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>find the queue for this writer partition</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">partitionQueue</span> =</span> logsToDeliver(requestServerId)
      <span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get the available log line</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">log</span> =</span> partitionQueue.dequeue()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>send it over</p></div></div><div class="code"><div class="wrapper">        sender() ! <span class="hljs-type">WriteLog</span>(args.serverID, log, partIdx)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>refill the queue</p></div></div><div class="code"><div class="wrapper">        fillUpQueue()
      } <span class="hljs-keyword">catch</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">NonFatal</span>(e) =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the queue was empty</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (!lines.hasNext) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we might be at the end of our workload</p></div></div><div class="code"><div class="wrapper">            checkEnd()
          } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the queue might have been empty for that partition as we don&#39;t have
any more logs available
mark the writer as blocked to send it a message later</p></div></div><div class="code"><div class="wrapper">            blockedWriters(requestServerId) = <span class="hljs-literal">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>fill up the queue</p></div></div><div class="code"><div class="wrapper">            fillUpQueue()
          }
      }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>a lazy iterator over the lines of the file we are assigned. inputFiles are supposed to be contiguous, sorted
 buckets.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lineIterator</span>(</span>): <span class="hljs-type">BufferedIterator</span>[<span class="hljs-type">IdAndLine</span>] = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>use an iterator to lazily load the lines
make it buffered so we can peak at the head of the iterator
new JoinIterators(inputFiles).map(IdAndLine).buffered</p></div></div><div class="code"><div class="wrapper">    inputFiles.toIterator.flatMap(f=&gt; <span class="hljs-type">Source</span>.fromFile(f).getLines.map(<span class="hljs-type">IdAndLine</span>)).buffered
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>when we are done filling the queues, notify the writers that might be blocked and for which a line is available</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notifyWriters</span>(</span>): <span class="hljs-type">Unit</span> = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>notify the writers that some logs have been made available</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> until logsToDeliver.size) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>but only for non empty queues</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (logsToDeliver(i).size &gt; <span class="hljs-number">0</span> &amp;&amp; blockedWriters(i)) {
        blockedWriters(i) = <span class="hljs-literal">false</span>
        writers(i) ! <span class="hljs-type">LogAvailable</span>
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>fill up the queues until the next line is of a partition whose queue is full</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fillUpQueue</span>(</span>): <span class="hljs-type">Unit</span> = {
    <span class="hljs-annotation">@tailrec</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurseFillUp</span>(</span>) {
      <span class="hljs-keyword">if</span> (lines.hasNext) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>check the top of the file</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">logLine</span> =</span> lines.head</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>assign a partition to that log line</p></div></div><div class="code"><div class="wrapper">        logLine.partition(args.numServers) <span class="hljs-keyword">match</span> {
          <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(partition) =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>valid line, find the right queue and push it</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">partitionQueue</span> =</span> logsToDeliver(partition)
            <span class="hljs-keyword">if</span> (partitionQueue.size &lt; args.maxReadBuffer) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>but only if the buffer is not full, otherwise, we are done filling up queues</p></div></div><div class="code"><div class="wrapper">              partitionQueue.enqueue(logLine)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move the iterator we just read with</p></div></div><div class="code"><div class="wrapper">              lines.next()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>start again until we can&#39;t read more messages</p></div></div><div class="code"><div class="wrapper">              recurseFillUp()
            }
          <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>invalid line, cannot be parsed, drop it</p></div></div><div class="code"><div class="wrapper">            log.debug(<span class="hljs-string">"{} couldn't be parsed"</span>, logLine)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move the iterator forward</p></div></div><div class="code"><div class="wrapper">            lines.next()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>try to fill with the next line</p></div></div><div class="code"><div class="wrapper">            recurseFillUp()
        }
      }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>try to fill the buffers</p></div></div><div class="code"><div class="wrapper">    recurseFillUp()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>let the writers know that we have more work (maybe)</p></div></div><div class="code"><div class="wrapper">    notifyWriters()
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>go the writer on each node to register this reader for work pulling</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>(</span>member: <span class="hljs-type">Member</span>): <span class="hljs-type">Unit</span> = {
    <span class="hljs-keyword">if</span> (member.hasRole(<span class="hljs-string">"logsplit"</span>)) {
      context.actorSelection(<span class="hljs-type">RootActorPath</span>(member.address) / <span class="hljs-string">"user"</span> / <span class="hljs-string">"writer"</span>) ! <span class="hljs-type">RegisterReader</span>(args.serverID, partIdx, totalReaders)
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we are at the end of the read when the lines are done and all
queues have drained</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkEnd</span>(</span>): <span class="hljs-type">Unit</span> = {
    <span class="hljs-keyword">if</span> (!lines.hasNext &amp;&amp; logsToDeliver.forall(_.isEmpty)) {
      log.info(<span class="hljs-string">"Reader {}.{} is done"</span>, args.serverID, partIdx)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we are done, send a message to all writers</p></div></div><div class="code"><div class="wrapper">      writers.foreach(_ ! <span class="hljs-type">LogDone</span>(args.serverID, partIdx))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> and stop this actor</p></div></div><div class="code"><div class="wrapper">      context.stop(self)
    }
  }
}</div></div></div></div></body></html>