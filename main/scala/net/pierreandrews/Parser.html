<!DOCTYPE html><html lang="en"><head><title>main/scala/net/pierreandrews/Parser</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../"><meta name="groc-document-path" content="main/scala/net/pierreandrews/Parser"><meta name="groc-project-path" content="src/main/scala/net/pierreandrews/Parser.scala"><link rel="stylesheet" type="text/css" media="all" href="../../../../assets/style.css"><script type="text/javascript" src="../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/main/scala/net/pierreandrews/Parser.scala</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">package net.pierreandrews

<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.util.Locale</span>

<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> scala.util.Try</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> scala.util.hashing.MurmurHash3</span>

<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> org.joda.time.DateTime</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> org.joda.time.format.DateTimeFormat</span>

object Parser {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>parse the log lines. Naive implementation</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>use joda DateTime as java SimpleDateFormat is unreliable
assume English log dates of the form: 13/Oct/2014:08:06:37 -0700</p></div></div><div class="code"><div class="wrapper">  private final val dateformat = DateTimeFormat.<span class="hljs-function"><span class="hljs-title">forPattern</span><span class="hljs-params">(<span class="hljs-string">"dd/MMM/yyyy:HH:mm:ss Z"</span>)</span></span>.<span class="hljs-function"><span class="hljs-title">withLocale</span><span class="hljs-params">(Locale.ENGLISH)</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>extract a date, might fail and return None</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extractDate</span><span class="hljs-params">(line: String)</span>:</span> Option[DateTime] = {
    val dateIdx = line.indexOf(<span class="hljs-string">'['</span>)
    <span class="hljs-keyword">if</span> (dateIdx &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">None</span>
    } <span class="hljs-keyword">else</span> {
      val endIdx = line.indexOf(<span class="hljs-string">']'</span>)
      <span class="hljs-keyword">if</span> (endIdx &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">None</span>
      } <span class="hljs-keyword">else</span> {
        val date = line.substring(dateIdx + <span class="hljs-number">1</span>, endIdx)
        Try(dateformat.parseDateTime(date)).toOption
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>extract a userid, might fail and return None
we expect user ids to be between userid=&quot; and a closing &quot;
we do not assume much about the format of the id itself.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extractUser</span><span class="hljs-params">(line: String)</span>:</span> Option[String] = {
    val userIdx = line.indexOfSlice(<span class="hljs-string">""""userid="""</span>) + <span class="hljs-number">8</span>
    <span class="hljs-keyword">if</span> (userIdx &lt; <span class="hljs-number">8</span>) {
      <span class="hljs-keyword">None</span>
    } <span class="hljs-keyword">else</span> {
      val userEnd = line.indexOf(<span class="hljs-string">'"'</span>, userIdx)
      <span class="hljs-keyword">if</span> (userEnd &gt; <span class="hljs-number">0</span>) {
        Some(line.substring(userIdx, userEnd))
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">None</span>
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>assign a userid to a partition (server node) where it&#39;s log line will be gathered.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">def</span> partition(<span class="hljs-string">userid:</span> String, <span class="hljs-string">numServers:</span> Int) = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>murmur hash is faster than cryptographic hashes and has a good distribution
so log lines will be evenly distributed to server.
The design of this splitter system assumes that userids are distributed evenly between each server,
using the murmur hash means that around a third of each log lines will be send over to another node (if we
have three servers). If the users are not balanced (all the logs for one users are always on one node), then this
will generate more network IO than really needed, if this is the case, we should adopt another strategy (see README)</p></div></div><div class="code"><div class="wrapper">    Math.<span class="hljs-built_in">abs</span>(MurmurHash3.stringHash(userid) <span class="hljs-comment">% numServers)</span>
  }

}</div></div></div></div></body></html>