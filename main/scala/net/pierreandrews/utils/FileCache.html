<!DOCTYPE html><html lang="en"><head><title>main/scala/net/pierreandrews/utils/FileCache</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../"><meta name="groc-document-path" content="main/scala/net/pierreandrews/utils/FileCache"><meta name="groc-project-path" content="src/main/scala/net/pierreandrews/utils/FileCache.scala"><link rel="stylesheet" type="text/css" media="all" href="../../../../../assets/style.css"><script type="text/javascript" src="../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/main/scala/net/pierreandrews/utils/FileCache.scala</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">package net.pierreandrews.utils

<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.{ File, FileWriter, PrintWriter }</span>

<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> net.pierreandrews.LogSplitAppArgs</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> net.pierreandrews.Protocol.IdAndLine</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A LRU of PrintWriters that opens/close the files when needed
 and tries to minimize the handle rotations.</p>
<p> We cannot predict the number of users that will be in the logs or when we&#39;ll have processed all the logs for
 a particular user. So we do not want to keep handles open for ALL the users nor do we want to keep
 reopening handles.</p>
<p> The Least Recently Used (LRU) strategy keeps the most often used file handles open and closes the other ones.</p>
<p>User: pierre
Date: 11/28/14</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">FileCache</span><span class="hljs-container">(<span class="hljs-title">args</span>: <span class="hljs-type">LogSplitAppArgs</span>)</span> {
</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we need to override the apache LRU to close the handles when they get expelled from the cache.
 This bugs in scala, so the override is done in java. See LRUOfFiles.java</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">val</span> <span class="hljs-title">lruCache</span> =</span> <span class="hljs-keyword">new</span> <span class="hljs-type">LRUOfFiles</span>(args.maxWriteOpen)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we write lines in a file per user, per reader;
this is because each reader has log lines sorted, but we don&#39;t know
how the partial order is organized between servers. We can only guarantee the order for the same reader
once we have all the log lines, we can start a merging step that will merge all the partially ordered files (see SorterActor)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span><span class="hljs-params">(log: IdAndLine, readerId: Int, partId: Int)</span>:</span> Unit = {
    log.userid.foreach { userid =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if we could parse the userid from the log line, get the file handle for that user/node/part.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-title">val</span> filename = s<span class="hljs-string">"<span class="hljs-variable">${userid}</span>.<span class="hljs-variable">$readerId</span>.<span class="hljs-variable">$partId</span>.part"</span>
      val writer = Option(lruCache.get(filename)).getOrElse {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if the cache doesn&#39;t contain the handle
create a new one</p></div></div><div class="code"><div class="wrapper">        val <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(args.output, filename)
        val <span class="hljs-keyword">newWriter</span> = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-keyword">file</span>, <span class="hljs-keyword">true</span>)) <span class="hljs-comment">//true to append to a possibly existing file</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>and add it to the cache</p></div></div><div class="code"><div class="wrapper">        lruCache.put(filename, newWriter)
        newWriter
      }
      writer.println(log.line)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span><span class="hljs-params">()</span>:</span> Unit = {
    lruCache.closeAll()
  }

}</div></div></div></div></body></html>