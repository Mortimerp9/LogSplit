<!DOCTYPE html><html lang="en"><head><title>main/scala/net/pierreandrews/utils/LineSorter</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../"><meta name="groc-document-path" content="main/scala/net/pierreandrews/utils/LineSorter"><meta name="groc-project-path" content="src/main/scala/net/pierreandrews/utils/LineSorter.scala"><meta name="groc-github-url" content="https://github.com/Mortimerp9/LogSplit"><link rel="stylesheet" type="text/css" media="all" href="../../../../../assets/style.css"><script type="text/javascript" src="../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Mortimerp9/LogSplit/blob/master/src/main/scala/net/pierreandrews/utils/LineSorter.scala">src/main/scala/net/pierreandrews/utils/LineSorter.scala</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">package net<span class="hljs-class">.pierreandrews</span><span class="hljs-class">.utils</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>An Iterator that takes in a set of partially sorted inputs and merges them in a sorted manned, in descending order.</p>
<p>If the inputs are not partially sorted, than the output will not be sorted properly. This sorter more or less
only needs inputs.size*size(I) memory as it lazily loads each line from the inputs.</p>
<p>The second parameter is a function that extracts the field to be sorted on. It extracts it in an Option as the extraction
might fail (i.e. we can&#39;t parse the date out of the logline)</p>
<p>User: pierre
Date: 11/30/14</p></div></div><div class="code"><div class="wrapper">class LineSorter[<span class="hljs-link_label">I, T: Ordering</span>](<span class="hljs-link_url">inputs: Seq[Iterator[I]], extractOrderField: I =&gt; Option[T]</span>) extends Iterator[I] {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>filter out the log lines to only keep the ones
which are parseable.
This flatMap is done on an iterator, so it&#39;s executed lazily only when the line is pulled.</p></div></div><div class="code"><div class="wrapper">  private val <span class="hljs-variable">bufferedInputs =</span> inputs.<span class="hljs-built_in">map</span>(_.flatMap { <span class="hljs-variable">l=</span>&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get rid of the lines we can&#39;t parse</p></div></div><div class="code"><div class="wrapper">    extractOrderField<span class="hljs-comment">(l)</span>.map { <span class="hljs-comment">(_, l)</span> }
  }.buffered)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we buffer the iterator so that we can peak at the top of the iterator without moving it forward.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p> there are more lines in this iterator if at least one of the underlying iterators has more lines</p></div></div><div class="code"><div class="wrapper">  override <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasNext</span>:</span> Boolean = {
    bufferedInputs.exists(_.hasNext)
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>extract the next line, choosing the one with the maximum sorting field from all the available iterators
returns the maximum next line</p></div></div><div class="code"><div class="wrapper">  override <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span><span class="hljs-params">()</span>:</span> I = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>only get the possible next line from the iterators that still have content available
we will then figure out which one to return</p></div></div><div class="code"><div class="wrapper">    val possibleNext = bufferedInputs.collect {
      <span class="hljs-keyword">case</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span>.hasNext =&gt;
        (<span class="hljs-keyword">it</span>.head, <span class="hljs-keyword">it</span>)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>find out the maximum ordering field from the possible next lines
maxBy will sort the iterator in descending order.</p></div></div><div class="code"><div class="wrapper">    val ((sortField, maxNext), itToAdvance) = possibleNext.maxBy {
      <span class="hljs-reserved">case</span> (<span class="hljs-function"><span class="hljs-params">(headOrder, _)</span>, _) =&gt;</span>
        headOrder
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move the chosen iterator forward</p></div></div><div class="code"><div class="wrapper">    itToAdvance.<span class="hljs-function"><span class="hljs-title">next</span><span class="hljs-params">()</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return the line from that iterator</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-title">maxNext</span>
  }
}</div></div></div></div></body></html>